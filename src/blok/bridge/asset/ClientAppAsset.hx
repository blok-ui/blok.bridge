package blok.bridge.asset;

import kit.file.*;
import blok.bridge.project.Project;

using haxe.io.Path;
using blok.bridge.cli.CliTools;

class ClientAppAsset implements Asset {
  final fs:FileSystem;
  final project:Project;
  final islands:IslandContext;

  public function new(fs, project, islands) {
    this.fs = fs;
    this.project = project;
    this.islands = islands;
  }

  public function getIdentifier():Null<String> {
    return '__blok.island.island-asset';
  }

  public function process(context:AppContext):Task<Nothing> {
    return outputMainFile().next(_ -> runHaxeCommand());
  }

  // function isBuildNeeded() {

  // }

  function runHaxeCommand():Task<Nothing> {
    var path = createHaxeCommand();
    return switch Sys.command(path) {
      case 0: Nothing;
      case _: new Error(InternalError, 'Failed to generate haxe file');
    }
  }

  function createHaxeCommand() {
    var cmd = [ 
      'haxe'.createNodeCommand(),
      '-D blok.client',
      '-cp ${project.paths.privateDirectory}',
      '-main ${project.islands.main}',
      '-js ${project.getIslandOutputPath()}'
    ].concat(project.toFlags({ isClient: true }));

    #if debug
    trace(cmd.join(' '));
    #end

    return cmd.join(' ');
  }

  function outputMainFile() {
    var path = project.islands.main.withExtension('hx');
    var contents = '// THIS FILE IS AUTOMATICALLY GENERATED.
//
// Don\'t edit it or commit it to version control.

function main() {
  hydrateIslands();
}

private function hydrateIslands() {
  var adaptor = new blok.html.client.ClientAdaptor();
  ${[for (island in islands.getIslandPaths()) {
    '$island.hydrateIslands(adaptor);';
  }].join('\n  ')}
}
';
    return fs.directory(project.paths.privateDirectory)
      .file(path)
      .write(contents);
  }
}
